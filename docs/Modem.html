<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Device::Modem - Perl extension to talk to modem devices connected via serial port</title>
<link rev="made" href="mailto:cosimo@cpan.org" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#warning">WARNING</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#things_device__modem_can_do">Things <code>Device::Modem</code> can do</a></li>
		<li><a href="#things_device__modem_can_t_do_yet">Things <code>Device::Modem</code> can't do yet</a></li>
		<li><a href="#things_it_will_never_be_able_to_do">Things it will never be able to do</a></li>
		<li><a href="#examples">Examples</a></li>
	</ul>

	<li><a href="#methods">METHODS</a></li>
	<ul>

		<li><a href="#answer__"><code>answer()</code></a></li>
		<li><a href="#atsend__"><code>atsend()</code></a></li>
		<li><a href="#attention__"><code>attention()</code></a></li>
		<li><a href="#connect__"><code>connect()</code></a></li>
		<li><a href="#dial__"><code>dial()</code></a></li>
		<li><a href="#disconnect__"><code>disconnect()</code></a></li>
		<li><a href="#echo__"><code>echo()</code></a></li>
		<li><a href="#hangup__"><code>hangup()</code></a></li>
		<li><a href="#is_active__"><code>is_active()</code></a></li>
		<li><a href="#log__"><code>log()</code></a></li>
		<li><a href="#new__"><code>new()</code></a></li>
		<li><a href="#offhook__"><code>offhook()</code></a></li>
		<li><a href="#parse_answer__"><code>parse_answer()</code></a></li>
		<li><a href="#port__"><code>port()</code></a></li>
		<li><a href="#repeat__"><code>repeat()</code></a></li>
		<li><a href="#reset__"><code>reset()</code></a></li>
		<li><a href="#restore_factory_settings__"><code>restore_factory_settings()</code></a></li>
		<li><a href="#s_register__"><code>S_register()</code></a></li>
		<li><a href="#send_init_string__"><code>send_init_string()</code></a></li>
		<li><a href="#status__"><code>status()</code></a></li>
		<li><a href="#store_number__"><code>store_number()</code></a></li>
		<li><a href="#verbose__"><code>verbose()</code></a></li>
		<li><a href="#wait__"><code>wait()</code></a></li>
	</ul>

	<li><a href="#requires">REQUIRES</a></li>
	<li><a href="#export">EXPORT</a></li>
	<li><a href="#todo">TO-DO</a></li>
	<li><a href="#faq">FAQ</a></li>
	<li><a href="#support">SUPPORT</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Device::Modem - Perl extension to talk to modem devices connected via serial port</p>
<p>
</p>
<hr />
<h1><a name="warning">WARNING</a></h1>
<p>This is <strong>BETA</strong> software, so use it at your own risk,
and without <strong>ANY</strong> warranty! Have fun.</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  use Device::Modem;</pre>
<pre>
  my $modem = new Device::Modem( port =&gt; '/dev/ttyS1' );</pre>
<pre>
  if( $modem-&gt;connect( baudrate =&gt; 9600 ) ) {
      print &quot;connected!\n&quot;;
  } else {
      print &quot;sorry, no connection with serial port!\n&quot;;
  }</pre>
<pre>
  $modem-&gt;attention();          # send `attention' sequence (+++)</pre>
<pre>
  ($ok, $answer) = $modem-&gt;dial('02270469012');  # dial phone number
  $ok = $modem-&gt;dial(3);        # 1-digit parameter = dial number stored in memory 3</pre>
<pre>
  $modem-&gt;echo(1);              # enable local echo (0 to disable)</pre>
<pre>
  $modem-&gt;offhook();            # Take off hook (ready to dial)
  $modem-&gt;hangup();             # returns modem answer</pre>
<pre>
  $modem-&gt;is_active();          # Tests whether modem device is active or not
                                # So far it works for modem OFF/ modem ON condition</pre>
<pre>
  $modem-&gt;reset();              # hangup + attention + restore setting 0 (Z0)</pre>
<pre>
  $modem-&gt;restore_factory_settings();  # Handle with care!
  $modem-&gt;restore_factory_settings(1); # Same with preset profile 1 (can be 0 or 1)</pre>
<pre>
  $modem-&gt;send_init_string();   # Send initialization string
                                # Now this is fixed to 'AT H0 Z S7=45 S0=0 Q0 V1 E0 &amp;C0 X4'</pre>
<pre>
  # Get/Set value of S1 register
  my $S1 = $modem-&gt;S_register(1);
  my $S1 = $modem-&gt;S_register(1, 55); # Don't do that if you definitely don't know!</pre>
<pre>
  # Get status of managed signals (CTS, DSR, RLSD, RING)
  my %signal = $modem-&gt;status();
  if( $signal{DSR} ) { print &quot;Data Set Ready signal active!\n&quot;; }</pre>
<pre>
  # Stores this number in modem memory number 3
  $modem-&gt;store_number(3, '01005552817');</pre>
<pre>
  $modem-&gt;repeat();             # Repeat last command</pre>
<pre>
  $modem-&gt;verbose(1);           # Normal text responses (0=numeric codes)</pre>
<pre>
  # Some raw AT commands
  $modem-&gt;atsend( 'ATH0' );
  print $modem-&gt;answer();</pre>
<pre>
  $modem-&gt;atsend( 'ATDT01234567' . Device::Modem::CR );
  print $modem-&gt;answer();</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p><code>Device::Modem</code> class implements basic <strong>AT (Hayes) compliant</strong> device abstraction.
It can be inherited by sub classes (as <code>Device::Gsm</code>), which are based on serial connections.</p>
<p>
</p>
<h2><a name="things_device__modem_can_do">Things <code>Device::Modem</code> can do</a></h2>
<ul>
<li></li>
connect to a modem on your serial port
<p></p>
<li></li>
test if the modem is alive and working
<p></p>
<li></li>
dial a number and connect to a remote modem
<p></p>
<li></li>
work with registers and settings of the modem
<p></p>
<li></li>
issue standard or arbitrary <code>AT</code> commands, getting results from modem
<p></p></ul>
<p>
</p>
<h2><a name="things_device__modem_can_t_do_yet">Things <code>Device::Modem</code> can't do yet</a></h2>
<ul>
<li></li>
Transfer a file to a remote modem
<p></p>
<li></li>
Control a terminal-like (or a PPP) connection. This should really not
be very hard to do anyway.
<p></p>
<li></li>
Many others...
<p></p></ul>
<p>
</p>
<h2><a name="things_it_will_never_be_able_to_do">Things it will never be able to do</a></h2>
<ul>
<li></li>
Coffee :-)
<p></p></ul>
<p>
</p>
<h2><a name="examples">Examples</a></h2>
<p>In the `examples' directory, there are some scripts that should work without big problems,
that you can take as (yea) examples:</p>
<dl>
<dt><strong><a name="item__60examples_2factive_2epl_27">`examples/active.pl'</a></strong><br />
</dt>
<dd>
Tests if modem is alive
</dd>
<p></p>
<dt><strong><a name="item__60examples_2fcaller_2did_2epl_27">`examples/caller-id.pl'</a></strong><br />
</dt>
<dd>
Waits for an incoming call and displays date, time and phone number of the caller.
Normally this is available everywhere, but you should check your local phone line
and settings.
</dd>
<p></p>
<dt><strong><a name="item__60examples_2fdial_2epl_27">`examples/dial.pl'</a></strong><br />
</dt>
<dd>
Dials a phone number and display result of call
</dd>
<p></p>
<dt><strong><a name="item__60examples_2fshell_2epl_27">`examples/shell.pl'</a></strong><br />
</dt>
<dd>
(Very) poor man's minicom/hyperterminal utility
</dd>
<p></p>
<dt><strong><a name="item__60examples_2fxmodem_2epl_27">`examples/xmodem.pl'</a></strong><br />
</dt>
<dd>
First attempt at a test script to receive a file via xmodem protocol.
Please be warned that this thing does not have a chance to work. It's
only a (very low priority) work in progress...
</dd>
<dd>
<p>If you want to help out, be welcome!</p>
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<p>
</p>
<h2><a name="answer__"><code>answer()</code></a></h2>
<p>One of the most used methods, waits for an answer from the device. It waits until
$timeout (seconds) is reached (but don't rely on this time to be very correct) or until an
expected string is encountered. Example:</p>
<pre>
        $answer = $modem-&gt;answer( [$expect [, $timeout]] )</pre>
<p>Returns <code>$answer</code> that is the string received from modem stripped of all
<strong>Carriage Return</strong> and <strong>Line Feed</strong> chars <strong>only</strong> at the beginning and at the end of the
string. No in-between <strong>CR+LF</strong> are stripped.</p>
<p>Note that if you need the raw answer from the modem, you can use the <code>_answer()</code> (note
that underscore char before answer) method, which does not strip anything from the response,
so you get the real modem answer string.</p>
<p>Parameters:</p>
<ul>
<li></li>
<code>$expect</code> - Can be a regexp compiled with <code>qr</code> or a simple substring. Input coming from the
modem is matched against this parameter. If input matches, result is returned.
<p></p>
<li></li>
<code>$timeout</code> - Expressed in seconds. After that time, answer returns result also if nothing
has been received. Example: <code>10</code>. Default: <code>0.2</code>
<p></p></ul>
<p>
</p>
<h2><a name="atsend__"><code>atsend()</code></a></h2>
<p>Sends a raw <code>AT</code> command to the device connected. Note that this method is most used
internally, but can be also used to send your own custom commands. Example:</p>
<pre>
        $ok = $modem-&gt;atsend( $msg )</pre>
<p>The only parameter is <code>$msg</code>, that is the raw AT command to be sent to
modem expressed as string. You must include the <code>AT</code> prefix and final
<strong>Carriage Return</strong> and/or <strong>Line Feed</strong> manually. There is the special constant
<code>CR</code> that can be used to include such a char sequence into the at command.</p>
<p>Returns <code>$ok</code> flag that is true if all characters are sent successfully, false
otherwise.</p>
<p>Example:</p>
<pre>
        # Enable verbose messages
        $modem-&gt;atsend( 'AT V1' . Device::Modem::CR );</pre>
<pre>
        # The same as:
        $modem-&gt;verbose(1);</pre>
<p>
</p>
<h2><a name="attention__"><code>attention()</code></a></h2>
<p>This command sends an <strong>attention</strong> sequence to modem. This allows modem
to pass in <strong>command state</strong> and accept <strong>AT</strong> commands. Example:</p>
<pre>
        $ok = $modem-&gt;attention()</pre>
<p>
</p>
<h2><a name="connect__"><code>connect()</code></a></h2>
<p>Connects <code>Device::Modem</code> object to the specified serial port.
There are options (the same options that <code>Device::SerialPort</code> has) to control
the parameters associated to serial link. Example:</p>
<pre>
        $ok = $modem-&gt;connect( [%options] )</pre>
<p>List of allowed options follows:</p>
<dl>
<dt><strong><a name="item_baudrate"><code>baudrate</code></a></strong><br />
</dt>
<dd>
Controls the speed of serial communications. The default is <strong>19200</strong> baud, that should
be supported by all modern modems. However, here you can supply a custom value.
Common speed values: 300, 1200, 2400, 4800, 9600, 19200, 38400, 57600,
115200.
This parameter is handled directly by <code>Device::SerialPort</code> object.
</dd>
<p></p>
<dt><strong><a name="item_databits"><code>databits</code></a></strong><br />
</dt>
<dd>
This tells how many bits your data word is composed of.
Default (and most common setting) is <code>8</code>.
This parameter is handled directly by <code>Device::SerialPort</code> object.
</dd>
<p></p>
<dt><strong><a name="item_init_string"><code>init_string</code></a></strong><br />
</dt>
<dd>
Custom initialization string can be supplied instead of the built-in one, that is the
following: <code>H0 Z S7=45 S0=0 Q0 V1 E0 &amp;C0 X4</code>, that is taken shamelessly from
<code>minicom</code> utility, I think.
</dd>
<p></p>
<dt><strong><a name="item_parity"><code>parity</code></a></strong><br />
</dt>
<dd>
Controls how parity bit is generated and checked.
Can be <strong>even</strong>, <strong>odd</strong> or <strong>none</strong>. Default is <strong>none</strong>.
This parameter is handled directly by <code>Device::SerialPort</code> object.
</dd>
<p></p>
<dt><strong><a name="item_stopbits"><code>stopbits</code></a></strong><br />
</dt>
<dd>
Tells how many bits are used to identify the end of a data word.
Default (and most common usage) is <code>1</code>.
This parameter is handled directly by <code>Device::SerialPort</code> object.
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="dial__"><code>dial()</code></a></h2>
<p>Takes the modem off hook, dials the specified number and returns modem answer.
Usage:</p>
<pre>
        # Simple usage (timeout is optional)
        $ok = $modem-&gt;dial( $number [,$timeout] )</pre>
<pre>
        # List context: allows to get at exact modem answer
        # like `CONNECT 19200/...', `BUSY', `NO CARRIER', ...
        ($ok, $answer) = $modem-&gt;dial( $number [,$timeout] )</pre>
<p>If called in <strong>scalar context</strong>, returns only success of connection. If modem answer
contains <code>CONNECT</code> string, <code>dial()</code> returns successful state, else false value
is returned.</p>
<p>If called in <strong>list context</strong>, returns the same <code>$ok</code> flag, but also the exact
modem answer to the dial operation in the <code>$answer</code> scalar. <code>$answer</code> typically
can contain strings like <code>CONNECT 19200</code> or <code>NO CARRIER</code>, <code>BUSY</code>, ... all standard
modem answers to a dial command.</p>
<p>Parameters are:</p>
<ul>
<li></li>
<code>$number</code> - this is the phone number to dial. If <code>$number</code> is only 1 digit, it is interpreted
as: <strong>dial number in my address book position <code>$number</code></strong>. So if your code is:
<pre>
        $modem-&gt;dial( 2, 10 );</pre>
<p>This means: dial number in the modem internal address book (see <code>store_number</code> for a way to
read/write address book) in position number <strong>2</strong> and wait for a timeout of <strong>10</strong> seconds.</p>
<p></p>
<li></li>
<code>$timeout</code> - timeout expressed in seconds to wait for the remote device to answer.
Please do not expect an <strong>exact</strong> wait for the number of seconds you specified. I'm still
studying how to do that exactly.
<p></p></ul>
<p>
</p>
<h2><a name="disconnect__"><code>disconnect()</code></a></h2>
<p>Disconnects <code>Device::Modem</code> object from serial port. This method calls underlying
<code>disconnect()</code> of <code>Device::SerialPort</code> object.
Example:</p>
<pre>
        $modem-&gt;disconnect();</pre>
<p>
</p>
<h2><a name="echo__"><code>echo()</code></a></h2>
<p>Enables or disables local echo of commands. This is managed automatically by <code>Device::Modem</code>
object. Normally you should not need to worry about this. Usage:</p>
<pre>
        $ok = $modem-&gt;echo( $enable )</pre>
<p>
</p>
<h2><a name="hangup__"><code>hangup()</code></a></h2>
<p>Does what it is supposed to do. Hang up the phone thus terminating any active call.
Usage:</p>
<pre>
        $ok = $modem-&gt;hangup();</pre>
<p>
</p>
<h2><a name="is_active__"><code>is_active()</code></a></h2>
<p>Can be used to check if there is a modem attached to your computer.
If modem is alive and responding (on serial link, not to a remote call),
<code>is_active()</code> returns true (1), otherwise returns false (0).</p>
<p>Test of modem activity is done through DSR (Data Set Ready) signal. If
this signal is in off state, modem is probably turned off, or not working.
From my tests I've found that DSR stays in ``on'' state after more or less
one second I turn off my modem, so know you know that.</p>
<p>Example:</p>
<pre>
        if( $modem-&gt;is_active() ) {
                # Ok!
        } else {
                # Modem turned off?
        }</pre>
<p>
</p>
<h2><a name="log__"><code>log()</code></a></h2>
<p>Simple accessor to log object instanced at object creation time.
Used internally. If you want to know the gory details, see <code>Device::Modem::Log::*</code> objects.
You can also see the <strong>examples</strong> for how to log something without knowing
all the gory details.</p>
<p><table cellspacing="0" cellpadding="0"><tr><td>Hint:
<tr><td><td>$modem-&gt;log-&gt;write('warning', 'ok, my log message here');</table></p>
<p>
</p>
<h2><a name="new__"><code>new()</code></a></h2>
<p><code>Device::Modem</code> constructor. This takes several options. A basic example:</p>
<pre>
        my $modem = Device::Modem-&gt;new( port =&gt; '/dev/ttyS0' );</pre>
<p>if under Linux or some kind of unix machine, or</p>
<pre>
        my $modem = Device::Modem-&gt;new( port =&gt; 'COM1' );</pre>
<p>if you are using a Win32 machine.</p>
<p>This builds the <code>Device::Modem</code> object with all the default parameters.
This should be fairly usable if you want to connect to a real modem.
Note that I'm testing it with a <strong>3Com US Robotics 56K Message</strong> modem
at <strong>19200</strong> baud and works ok.</p>
<p>List of allowed options:</p>
<ul>
<li></li>
<code>port</code> - serial port to connect to. On Unix, can be also a convenient link as
<em>/dev/modem</em> (the default value). For Win32, <code>COM1,2,3,4</code> can be used.
<p></p>
<li></li>
<code>log</code> - this specifies the method and eventually the filename for logging.
Logging process with <code>Device::Modem</code> is controlled by <strong>log plugins</strong>, stored under
<em>Device/Modem/Log/</em> folder. At present, there are two main plugins: <code>Syslog</code> and <code>File</code>.
<code>Syslog</code> does not work with Win32 machines.
When using <code>File</code> plug-in, all log information will be written to a default filename
if you don't specify one yourself. The default is <em>%WINBOOTDIR%\temp\modem.log</em> on
Win32 and <em>/var/log/modem.log</em> on Unix.
<p>Also there is the possibility to pass a <strong>custom log object</strong>, if this object
provides the following <code>write()</code> call:</p>
<pre>
        $log_object-&gt;write( $loglevel, $logmessage )</pre>
<p>You can simply pass this object (already instanced) as the <code>log</code> property.</p>
<p>Examples:</p>
<pre>
        # For Win32, default is to log in &quot;%WINBOOTDIR%/temp/modem.log&quot; file
        my $modem = Device::Modem-&gt;new( port =&gt; 'COM1' );</pre>
<pre>
        # Unix, custom logfile
        my $modem = Device::Modem-&gt;new( port =&gt; '/dev/ttyS0', log =&gt; 'file,/home/neo/matrix.log' )</pre>
<pre>
        # With custom log object
        my $modem = Device::modem-&gt;new( port =&gt; '/dev/ttyS0', log =&gt; My::LogObj-&gt;new() );</pre>
<p></p>
<li></li>
<code>loglevel</code> - default logging level. One of (order of decrescent verbosity): <code>debug</code>,
<code>verbose</code>, <code>notice</code>, <code>info</code>, <code>warning</code>, <code>err</code>, <code>crit</code>, <code>alert</code>, <code>emerg</code>.
<p></p></ul>
<p>
</p>
<h2><a name="offhook__"><code>offhook()</code></a></h2>
<p>Takes the modem ``off hook'', ready to dial. Normally you don't need to use this.
Also <code>dial()</code> goes automatically off hook before dialing.</p>
<p>
</p>
<h2><a name="parse_answer__"><code>parse_answer()</code></a></h2>
<p>This method works like <code>answer()</code>, it accepts the same parameters, but it
does not return the raw modem answer. Instead, it returns the answer string
stripped of all <strong>CR</strong>/<strong>LF</strong> characters at the beginning <strong>and</strong> at the end.</p>
<p><code>parse_answer()</code> is meant as an easy way of extracting result code
(<code>OK</code>, <code>ERROR</code>, ...) and information strings that can be sent by modem
in response to specific commands. Example:</p>
<pre>
        &gt; AT xSHOW_MODELx&lt;CR&gt;
        US Robotics 56K Message
        OK
        &gt;</pre>
<p>In this example, <code>OK</code> is the result and <code>US Robotics 56K Message</code> is the
informational message.</p>
<p>In fact, another difference with <code>answer()</code> is in the return value(s).
Here are some examples:</p>
<pre>
        $modem-&gt;atsend( '?my_at_command?' );
        $answer = $modem-&gt;parse_answer();</pre>
<p>where <code>$answer</code> is the complete response string, or:</p>
<pre>
        ($result, @lines) = $modem-&gt;parse_answer();</pre>
<p>where <code>$result</code> is the <code>OK</code> or <code>ERROR</code> final message and <code>@lines</code> is
the array of information messages (one or more lines). For the <em>model</em> example,
<code>$result</code> would hold ``<code>OK</code>'' and <code>@lines</code> would consist of only 1 line with
the string ``<code>US Robotics 56K Message</code>''.</p>
<p>
</p>
<h2><a name="port__"><code>port()</code></a></h2>
<p>Used internally. Accesses the <code>Device::SerialPort</code> underlying object. If you need to
experiment or do low-level serial calls, you may want to access this. Please report
any usage of this kind, because probably (?) it is possible to include it in a higher
level method.</p>
<p>
</p>
<h2><a name="repeat__"><code>repeat()</code></a></h2>
<p>Repeats the last <code>AT</code> command issued.
Usage:</p>
<pre>
        $ok = $modem-&gt;repeat()</pre>
<p>
</p>
<h2><a name="reset__"><code>reset()</code></a></h2>
<p>Tries in any possible way to reset the modem to the starting state, hanging up all
active calls, resending the initialization string and preparing to receive <code>AT</code>
commands.</p>
<p>
</p>
<h2><a name="restore_factory_settings__"><code>restore_factory_settings()</code></a></h2>
<p>Restores the modem default factory settings. There are normally two main ``profiles'',
two different memories for all modem settings, so you can load profile 0 and profile 1,
that can be different depending on your modem manufacturer.</p>
<p>Usage:</p>
<pre>
        $ok = $modem-&gt;restore_factory_settings( [$profile] )</pre>
<p>If no <code>$profile</code> is supplied, <code>0</code> is assumed as default value.</p>
<p>Check on your modem hardware manual for the meaning of these <strong>profiles</strong>.</p>
<p>
</p>
<h2><a name="s_register__"><code>S_register()</code></a></h2>
<p>Gets or sets an <strong>S register</strong> value. These are some internal modem registers that
hold important information that controls all modem behaviour. If you don't know
what you are doing, don't use this method. Usage:</p>
<pre>
        $value = $modem-&gt;S_register( $reg_number [, $new_value] );</pre>
<p><code>$reg_number</code> ranges from 0 to 99 (sure?).
If no <code>$new_value</code> is supplied, return value is the current register value.
If a <code>$new_value</code> is supplied (you want to set the register value), return value
is the new value or <code>undef</code> if there was an error setting the new value.</p>
<p>&lt;!-- Qui &amp;egrave; spiegata da cani --&gt;</p>
<p>Examples:</p>
<pre>
        # Get value of S7 register
        $modem-&gt;S_register(7);</pre>
<pre>
        # Set value of S0 register to 0
        $modem-&gt;S_register(0, 0);</pre>
<p>
</p>
<h2><a name="send_init_string__"><code>send_init_string()</code></a></h2>
<p>Sends the initialization string to the connected modem. Usage:</p>
<pre>
        $ok = $modem-&gt;send_init_string( [$init_string] );</pre>
<p>If you specified an <a href="#item_init_string"><code>init_string</code></a> as an option to <code>new()</code> object constructor,
that is taken by default to initialize the modem.
Else you can specify <code>$init_string</code> parameter to use your own custom intialization
string. Be careful!</p>
<p>
</p>
<h2><a name="status__"><code>status()</code></a></h2>
<p>Returns status of main modem signals as managed by <code>Device::SerialPort</code> (or <code>Win32::SerialPort</code>) objects.
The signals reported are:</p>
<dl>
<dt><strong><a name="item_cts">CTS</a></strong><br />
</dt>
<dd>
Clear to send
</dd>
<p></p>
<dt><strong><a name="item_dsr">DSR</a></strong><br />
</dt>
<dd>
Data set ready
</dd>
<p></p>
<dt><strong><a name="item_ring">RING</a></strong><br />
</dt>
<dd>
Active if modem is ringing
</dd>
<p></p>
<dt><strong><a name="item_rlsd">RLSD</a></strong><br />
</dt>
<dd>
??? Released line ???
</dd>
<p></p></dl>
<p>Return value of <code>status()</code> call is a hash, where each key is a signal name and
each value is &gt; 0 if signal is active, 0 otherwise.
Usage:</p>
<pre>
        ...
        my %sig = $modem-&gt;status();
        for ('CTS','DSR','RING','RLSD') {
                print &quot;Signal $_ is &quot;, ($sig{$_} &gt; 0 ? 'on' : 'off'), &quot;\n&quot;;
        }</pre>
<p>
</p>
<h2><a name="store_number__"><code>store_number()</code></a></h2>
<p>Store telephone number in modem internal address book, to be dialed later (see <code>dial()</code> method).
Usage:</p>
<pre>
        $ok = $modem-&gt;store_number( $position, $number )</pre>
<p>where <code>$position</code> is the address book memory slot to store phone number (usually from 0 to 9),
and <code>$number</code> is the number to be stored in the slot.
Return value is true if operation was successful, false otherwise.</p>
<p>
</p>
<h2><a name="verbose__"><code>verbose()</code></a></h2>
<p>Enables or disables verbose messages. This is managed automatically by <code>Device::Modem</code>
object. Normally you should not need to worry about this. Usage:</p>
<pre>
        $ok = $modem-&gt;verbose( $enable )</pre>
<p>
</p>
<h2><a name="wait__"><code>wait()</code></a></h2>
<p>Waits (yea) for a given amount of time (in milliseconds). Usage:</p>
<pre>
        $modem-&gt;wait( [$msecs] )</pre>
<p>Wait is implemented via <code>select</code> system call.
Don't know if this is really a problem on some platforms.</p>
<p>
</p>
<hr />
<h1><a name="requires">REQUIRES</a></h1>
<dl>
<dt><strong><a name="item_serialport">Device::SerialPort (Win32::SerialPort for Win32 machines)</a></strong><br />
</dt>
</dl>
<p>
</p>
<hr />
<h1><a name="export">EXPORT</a></h1>
<p>None</p>
<p>
</p>
<hr />
<h1><a name="todo">TO-DO</a></h1>
<dl>
<dt><strong><a name="item_autoscan">AutoScan</a></strong><br />
</dt>
<dd>
An AT command script with all interesting commands is run
when `autoscan' is invoked, creating a `profile' of the
current device, with list of supported commands, and database
of brand/model-specific commands
</dd>
<p></p>
<dt><strong><a name="item_serial_speed_autodetect">Serial speed autodetect</a></strong><br />
</dt>
<dd>
Now if you connect to a different baud rate than that of your modem,
probably you will get no response at all. It would be nice if <code>Device::Modem</code>
could auto-detect the speed to correctly connect at your modem.
</dd>
<p></p>
<dt><strong><a name="item_file_transfers">File transfers</a></strong><br />
</dt>
<dd>
It would be nice to implement <code>[xyz]modem</code> like transfers between
two <code>Device::Modem</code> objects connected with two modems.
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><a name="faq">FAQ</a></h1>
<p>There is a minimal FAQ document for this module online at
<a href="http://www.streppone.it/cosimo/work/perl/CPAN/Device-Modem/FAQ.html">http://www.streppone.it/cosimo/work/perl/CPAN/Device-Modem/FAQ.html</a></p>
<p>
</p>
<hr />
<h1><a name="support">SUPPORT</a></h1>
<p>Please feel free to contact me at my e-mail address <em><a href="mailto:cosimo@cpan.org">cosimo@cpan.org</a></em>
for any information, to resolve problems you can encounter with this module
or for any kind of commercial support you may need.</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Cosimo Streppone, <em><a href="mailto:cosimo@cpan.org">cosimo@cpan.org</a></em></p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>(C) 2002-2004 Cosimo Streppone, <em><a href="mailto:cosimo@cpan.org">cosimo@cpan.org</a></em></p>
<p>This library is free software; you can only redistribute it and/or
modify it under the same terms as Perl itself.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>Device::SerialPort,
Win32::SerialPort,
Device::Gsm,
perl</p>

</body>

</html>
